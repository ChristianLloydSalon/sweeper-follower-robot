#include <Arduino.h>
#include <Wire.h>
#include <TinyGPS.h>
#include <RobotMotion.h>
#include <NewPing.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_HMC5883_U.h>
#include <BlynkSimpleSerialBLE.h>

#ifndef MIN_GPS_DISTANCE
#define MIN_GPS_DISTANCE 1.5    
#endif

#ifndef MIN_ULTRASONIC_DISTANCE
#define MIN_ULTRASONIC_DISTANCE 20      
#endif

#ifndef ECHO_PIN
#define ECHO_PIN 26
#endif

#ifndef TRIGGER_PIN
#define TRIGGER_PIN 27
#endif

#ifndef MAX_PING_DISTANCE
#define MAX_PING_DISTANCE 200
#endif

#ifndef GPS_INTERVAL
#define GPS_INTERVAL 1000
#endif

#ifndef ULTRASONIC_INTERVAL 
#define ULTRASONIC_INTERVAL 50
#endif

// replace authentication key by the key generated by the blynk application
char authenticationKey[] = "vWVJ8YZeHavp5iXS4U2eBT1rOrop_azE";

TinyGPS onboardGPS;
Adafruit_HMC5883_Unified mag = Adafruit_HMC5883_Unified(12345);

// ENA - PIN2
// ENB - PIN3
// IN1 - PIN22
// IN2 - PIN23
// IN3 - PIN24
// IN4 - PIN25
RobotMotion robot(2, 22, 23, 3, 24, 25);

// initialize for ultrasonic
NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_PING_DISTANCE);

WidgetTerminal terminal1(V3);

bool enabled = false;

struct GeoLocation
{
     float latitude;
     float longitude;
};

// Onboard GPS location
GeoLocation onboardLocation;

// Mobile Phone GPS location
GeoLocation mobileLocation;

// distance message
float distanceMsg;

unsigned long gps_time_now = 0;

float bearingAngle = 0;
float headingAngle = 0;

void setup()
{
     Wire.begin();
     
     Serial.begin(9600);  // arduino serial
     Serial1.begin(9600); // onboard gps serial
     Serial2.begin(9600); // bluetooth serial

     while(!mag.begin())
     {
          Serial.println("Ooops, no HMC5883 detected ... Check your wiring!");
     }

     Blynk.begin(Serial2, authenticationKey); // initialize Blynk

     distanceMsg = 0;

     pinMode(TRIGGER_PIN, OUTPUT); // Sets the TRIGGER_PIN as an OUTPUT
     pinMode(ECHO_PIN, INPUT);     // Sets the ECHO_PIN as an INPUT

     terminal1.clear();

     robot.setSpeed(255);
     robot.Stop();

     gps_time_now = millis();
}

// overload != operator
bool operator!=(GeoLocation location, int num)
{
     if (location.latitude != num && location.longitude != num)
          return true;

     return false;
}

void displayGPSValues(String text, GeoLocation location, WidgetTerminal &terminal)
{
     if (location != 0)
     {
          terminal.print("Lat: ");
          terminal.println(location.latitude, 4);
          terminal.print("Lon: ");
          terminal.println(location.longitude, 4);
     }
     else
     {
          terminal.println("No GPS Reading from the " + text + "....");
     }
}

// Mobile GPS Stream
BLYNK_WRITE(V0)
{
     GpsParam mobileGPS(param);

     mobileLocation.latitude = mobileGPS.getLat();
     mobileLocation.longitude = mobileGPS.getLon();
}

// Killswitch
BLYNK_WRITE(V1)
{
     enabled = param.asInt();

     robot.Stop();
}

// DISPLAY DISTANCE AND TERMINAL
BLYNK_READ(V2)
{
     Blynk.virtualWrite(V2, distanceMsg);

     terminal1.clear();

     displayGPSValues("Onboard GPS", onboardLocation, terminal1);

     terminal1.print("B: ");
     terminal1.println(bearingAngle);
     terminal1.print("H: ");
     terminal1.println(headingAngle);

     terminal1.flush();
}

// bearing angle of A with respect to B
float bearing(GeoLocation A, GeoLocation B)
{
     float deltaL = B.longitude - A.longitude;

     float cosA = cos(A.latitude * DEG_TO_RAD);
     float cosB = cos(B.latitude * DEG_TO_RAD);
     float sinA = sin(A.longitude * DEG_TO_RAD);
     float sinB = sin(B.longitude * DEG_TO_RAD);

     float x = cosB * sin(deltaL * DEG_TO_RAD);
     float y = cosA * sinB - sinA * cosB * cos(deltaL * DEG_TO_RAD);

     float bearing = atan2(x, y) * RAD_TO_DEG;
     bearing = fmod((bearing + 360), 360);

     return bearing;
}

// heading degrees of the robot
float heading()
{
     sensors_event_t event; 
     mag.getEvent(&event);

     // Hold the module so that Z is pointing 'up' and you can measure the heading with x&y
     // Calculate heading when the magnetometer is level, then correct for signs of axis.
     float heading = atan2(event.magnetic.y, event.magnetic.x);
     
     // Once you have your heading, you must then add your 'Declination Angle', which is the 'Error' of the magnetic field in your location.
     float declinationAngle = (-1 + (35/60)) / (180/M_PI);
     heading -= declinationAngle;

     // Correct for when signs are reversed.
     if(heading < 0)
          heading += 2*PI;
     
     // Check for wrap due to addition of declination.
     if(heading > 2*PI)
          heading -= 2*PI;
     
     // Convert radians to degrees for readability.
     float headingDegrees = heading * 180/M_PI;

     return headingDegrees;
}

// get distance between two points using Havensine's formula
float distance(GeoLocation A, GeoLocation B)
{
     const float R = 6371000; // Earth's radius (km)
     float p1 = A.latitude * DEG_TO_RAD;
     float p2 = B.latitude * DEG_TO_RAD;
     float dp = (B.latitude - A.latitude) * DEG_TO_RAD;
     float dl = (A.longitude - B.longitude) * DEG_TO_RAD;

     float x = pow(sin(dp / 2), 2) +
               cos(p1) * cos(p2) *
               pow(sin(dl / 2), 2);

     float y = 2 * atan2(sqrt(x), sqrt(1 - x));

     return R * y;
}

// gets the ultrasonic readings (cm)
float getUltrasonicDistance()
{
     unsigned int microSeconds = sonar.ping(); // Send ping, get ping time in microseconds
     return sonar.convert_cm(microSeconds);    // Convert ping time to distance and print result (0 = outside set distance range, no ping echo)
}

float latitude = 0;
float longitude = 0;

void loop()
{
     Blynk.run();
     
     float ultrasonicReading = getUltrasonicDistance();     // get ultrasonic value (cm)

     if (Serial1.available())
     {
          if (onboardGPS.encode(Serial1.read()))
          {
               // get robot latitude and longitude
               onboardGPS.f_get_position(&latitude, &longitude);
          }
     }

     if(millis() >= gps_time_now + GPS_INTERVAL)
     {
          Serial.println("OK");
          gps_time_now += GPS_INTERVAL;

          onboardLocation.latitude = latitude;
          onboardLocation.longitude = longitude;
     }

     if (onboardLocation != 0 && mobileLocation != 0 && enabled)
     {
          bearingAngle = bearing(onboardLocation, mobileLocation);
          headingAngle = heading();

          float gpsDistance = distance(onboardLocation, mobileLocation);
          
          distanceMsg = gpsDistance;

          bool isArrived = (gpsDistance <= MIN_GPS_DISTANCE);
          bool isObstacleDetected = (ultrasonicReading <= MIN_ULTRASONIC_DISTANCE) && ultrasonicReading != 0;
          bool isForward = (headingAngle <= bearingAngle + 3) && (headingAngle >= bearingAngle - 3);
          
          if((isForward && isObstacleDetected) || isArrived)
          {
               Serial.println("Stop");
               robot.Stop();
          }
          else if(isForward && !isObstacleDetected && !isArrived)
          {
               robot.Stop();
               robot.Forward();
          }
          else if (headingAngle < bearingAngle)
          {
               int RIGHT = bearingAngle - headingAngle;
               int LEFT = 360 - RIGHT;

               if (RIGHT < LEFT)
               {
                    Serial.println("A Right");
                    robot.Right();
               }
               else
               {
                    Serial.println("A Left");
                    robot.Left();
               }
          }
          else if (headingAngle > bearingAngle)
          {
               int LEFT = headingAngle - bearingAngle;
               int RIGHT = 360 - LEFT;

               if (LEFT < RIGHT)
               {
                    Serial.println("B Left");
                    robot.Left();
               }
               else
                {
                    Serial.println("B Right");
                    robot.Right();
               }
          }
     }
     else
     {
          robot.Stop();
     }
}
#include <Arduino.h>
#include <Wire.h>
#include <TinyGPS.h>
#include <MechaQMC5883.h>
#include <RobotMotion.h>
#include <NewPing.h>
#include <BlynkSimpleSerialBLE.h>

#ifndef MIN_GPS_DISTANCE
#define MIN_GPS_DISTANCE 3
#endif

#ifndef MIN_ULTRASONIC_DISTANCE
#define MIN_ULTRASONIC_DISTANCE 12
#endif

#ifndef ECHO_PIN
#define ECHO_PIN 26
#endif

#ifndef TRIGGER_PIN
#define TRIGGER_PIN 27
#endif

#ifndef MAX_PING_DISTANCE
#define MAX_PING_DISTANCE 200
#endif

// replace authentication key by the key generated by the blynk application
char authenticationKey[] = "vWVJ8YZeHavp5iXS4U2eBT1rOrop_azE";

TinyGPS onboardGPS;
MechaQMC5883 compass;

// ENA - PIN2
// ENB - PIN3
// IN1 - PIN22
// IN2 - PIN23
// IN3 - PIN24
// IN4 - PIN25
RobotMotion robot(2, 22, 23, 3, 24, 25);

// initialize for ultrasonic
NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_PING_DISTANCE);

WidgetTerminal terminal1(V3);
WidgetTerminal terminal2(V4);

bool enabled = false;

struct GeoLocation
{
     float latitude;
     float longitude;
};

// Onboard GPS location
GeoLocation onboardLocation;

// Mobile Phone GPS location
GeoLocation mobileLocation;

// distance message
String distanceMsg;

void setup()
{
     Serial.begin(9600);  // arduino serial
     Serial1.begin(9600); // onboard gps serial
     Serial2.begin(9600); // bluetooth serial

     compass.init();                                               // initialize compass
     compass.setMode(Mode_Continuous, ODR_200Hz, RNG_2G, OSR_256); // set compass mode

     Blynk.begin(Serial2, authenticationKey); // initialize Blynk

     distanceMsg = "0m";

     pinMode(TRIGGER_PIN, OUTPUT); // Sets the TRIGGER_PIN as an OUTPUT
     pinMode(ECHO_PIN, INPUT);     // Sets the ECHO_PIN as an INPUT

     terminal1.clear();
     terminal2.clear();

     robot.setSpeed(255);
     robot.Stop();
}

// overload != operator
bool operator!=(GeoLocation location, int num)
{
     if (location.latitude != num && location.longitude != num)
          return true;

     return false;
}

void displayGPSValues(String text, GeoLocation location, WidgetTerminal &terminal)
{
     if (location != 0)
     {
          terminal.println(location.latitude, 10);
          terminal.println(location.longitude, 10);
     }
     else
     {
          terminal.println("Initializing " + text + "....");
     }
}

// Mobile GPS Stream
BLYNK_WRITE(V0)
{
     GpsParam mobileGPS(param);

     mobileLocation.latitude = mobileGPS.getLat();
     mobileLocation.longitude = mobileGPS.getLon();
}

// Killswitch
BLYNK_WRITE(V1)
{
     enabled = !enabled;

     robot.Stop();
}

// DISPLAY DISTANCE AND TERMINAL
BLYNK_READ(V2)
{
     terminal1.clear();
     terminal2.clear();

     Blynk.virtualWrite(V2, distanceMsg);

     displayGPSValues("Onboard GPS", onboardLocation, terminal1);
     displayGPSValues("Mobile GPS", mobileLocation, terminal2);

     terminal1.flush();
     terminal2.flush();
}

// bearing angle of A with respect to B
float bearing(GeoLocation A, GeoLocation B)
{
     float deltaL = B.longitude - A.longitude;

     float cosA = cos(A.latitude * DEG_TO_RAD);
     float cosB = cos(B.latitude * DEG_TO_RAD);
     float sinA = sin(A.longitude * DEG_TO_RAD);
     float sinB = sin(B.longitude * DEG_TO_RAD);

     float x = cosB * sin(deltaL * DEG_TO_RAD);
     float y = cosA * sinB - sinA * cosB * cos(deltaL * DEG_TO_RAD);

     float bearing = atan2(x, y) * RAD_TO_DEG;
     bearing = fmod((bearing + 360), 360);

     return bearing;
}

// heading degrees of the robot from the north
float heading()
{
     float _heading;
     int x, y, z;

     compass.read(&x, &y, &z);

     _heading = compass.azimuth(&y, &x);

     return _heading;
}

// get distance between two points using Havensine's formula
float distance(GeoLocation A, GeoLocation B)
{
     const float R = 6371000; // Earth's radius (km)
     float p1 = A.latitude * DEG_TO_RAD;
     float p2 = B.latitude * DEG_TO_RAD;
     float dp = (B.latitude - A.latitude) * DEG_TO_RAD;
     float dl = (A.longitude - B.longitude) * DEG_TO_RAD;

     float x = pow(sin(dp / 2), 2) +
               cos(p1) * cos(p2) *
                   pow(sin(dl / 2), 2);

     float y = 2 * atan2(sqrt(x), sqrt(1 - x));

     return R * y;
}

// gets the ultrasonic readings (cm)
float getUltrasonicDistance()
{
     const int period = 50;        // 50ms
     unsigned long time_now = 0;

     if (millis() >= time_now + period)
     {
          time_now += period;
          unsigned int microSeconds = sonar.ping(); // Send ping, get ping time in microseconds
          return sonar.convert_cm(microSeconds);    // Convert ping time to distance and print result (0 = outside set distance range, no ping echo)
     }

     return 9999;
}

void loop()
{
     Blynk.run();

     float ultrasonicReading = getUltrasonicDistance();     // get ultrasonic value (cm)

     if (Serial1.available())
     {
          if (onboardGPS.encode(Serial1.read()))
          {
               // get robot latitude and longitude
               onboardGPS.f_get_position(&onboardLocation.latitude, &onboardLocation.longitude);
          }
     }

     if (onboardLocation != 0 && mobileLocation != 0 && enabled)
     {
          int bearingAngle = (int)bearing(onboardLocation, mobileLocation);
          int headingAngle = (int)heading();

          float gpsDistance = distance(onboardLocation, mobileLocation);

          distanceMsg = String(gpsDistance) + "m";

          if (gpsDistance <= MIN_GPS_DISTANCE || ultrasonicReading <= MIN_ULTRASONIC_DISTANCE)
          {
               robot.Stop();
          }
          else if (headingAngle == bearingAngle)
          {
               robot.Forward();
          }
          else if (headingAngle < bearingAngle)
          {
               int RIGHT = bearingAngle - headingAngle;
               int LEFT = 360 - RIGHT;

               if (RIGHT < LEFT)
                    robot.Right();
               else
                    robot.Left();
          }
          else if (headingAngle > bearingAngle)
          {
               int LEFT = headingAngle - bearingAngle;
               int RIGHT = 360 - LEFT;

               if (LEFT < RIGHT)
                    robot.Left();
               else
                    robot.Right();
          }
     }
     else
     {
          robot.Stop();
     }
}
